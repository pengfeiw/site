<html lang="zh_cn"><head><title>跨域导致tainted canvas | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="简单介绍浏览器同源限制，浏览器缓存导致canvas图片跨域问题如何解决。"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年5月15日</span><span class="category"><a href="/blogs/javascript">标签：JavaScript</a></span></div><div class="markdown-body"><h1 id="谷歌浏览器缓存导致跨域，造成tainted canvas错误">谷歌浏览器缓存导致跨域，造成tainted canvas错误 <a href="#谷歌浏览器缓存导致跨域，造成tainted canvas错误">#</a></h1><p>最近工作中遇到了一个canvas绘制image的错误。是由于canvas在使用其他源的图片的时候，造成跨域导致，遇到这种问题一般我们只需要将图片的<strong>crossorigin</strong>设置下，然后请求响应头也需要设置<strong>access-control-allow-origin</strong>，即可解决问题。但是我遇到的问题比这要复杂一些，因为在前端和服务端都设置好的情况下，我的问题依然存在，依然报跨域。接下来我将详细解释相关内容。</p><p><img src="https://pengfeiw.github.io/images/blog/11.png" alt="cors图片"></p><h3 id="一. 同源限制">一. 同源限制 <a href="#一. 同源限制">#</a></h3><p>因为问题产生的根本原因时浏览器的**同源限制（same-origin-policy）**导致，所以我将简要介绍下这个概念。</p><p>浏览器安全的根基就是同源限制，何为同源限制呢，当且仅当两个域名满足以下三点，我们认为这两个域名是同源的：</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><p>有一点需要注意的是，<strong>标准规定的端口相同的才同源，但是浏览器并没有遵循这一项规定，也就是说如果两个网站协议相同，域名相同但是端口不相同，那么浏览器也认为其是同源的</strong>，例如<code>http:://www.pengfeixc.com:8000</code>和<code>http://www.pengfeixc.com:8001</code>这两个地址只有端口不一样，它们是不同源的，但是由于浏览器并未遵循这一规定，所以浏览器认为它们是同源的，所以它们是可以互相读取cookie的。</p><p>同源限制的目的是为了保证互联网的用户安全信息的，如果没有同源限制，不同源的网站可以互相读取cookie的话，那么会很危险的。设想一下，如果网站A把用户信息存储在cookie中，如果没有同源限制的情况下，网站B也可以读取网站A存储的cookie来获取用户信息，如果是比较重要的用户信息，那么后果将不敢想象。</p><p>所以出现了<strong>CORS（cross origin resource share）</strong>,即跨域资源共享。在请求非同源资源的时候必须通过<strong>CORS</strong>方式请求。 关于<strong>CORS</strong>，我就不在展开了，它就是一种请求非同源资源的方式。可以在<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a> 上获取详细信息。</p><h3 id="二.crossorigin属性">二.crossorigin属性 <a href="#二.crossorigin属性">#</a></h3><p>html5中一些html元素增加了crossorigin属性，提供了对cors的支持。例如<code>&lt;audio&gt;</code> 、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;video&gt;</code>都可以通过设置<code>crossorigin</code>属性来改变普通请求方式为cors请求。以img为例</p><pre><code class="hljs language-html"><span class="hljs-comment">&lt;!-- 以非跨域请求方式请求/1.jpg --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/1.jpg"</span>  <span class="hljs-attr">alt</span>=<span class="hljs-string">"图片"</span> /&gt;</span>
<span class="hljs-comment">&lt;!-- 以cors请求方式请求http://www.example.com/image/1.jpg --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.example.com/image/1.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"图片"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span> /&gt;</span>
</code></pre><p>crossorigin有如下取值：</p><ul><li><p>anonymous：执行一个cors请求，但是该请求不会发送相关证书，例如cookie。服务器需要相应的设置Access-control-Allow-Origin响应头，图片才是未被污染的。</p></li><li><p>use-credentials: 执行一个cors请求，该请求会发送相关证书，携带cookie和http基本验证信息。服务器需要相应设置Access-Control-Allow-Origin响应头。</p></li></ul><p>如果没有显示设置crossorigin属性，那么请求会是非跨域请求，如果图片来自非同源地址，那么该图片认为是被污染的。如果我们在canvas上绘制该图片，那么canvas将被认为是污染(tainted)的，被污染的canvas不能使用如下方法：</p><ul><li>在canvas context上调用getImageData()</li><li>在canvas元素上调用toBlob()</li><li>在canvas元素上调用toDataURL()</li></ul><p>总结就是<strong>我们不能在被污染的canvas上获取图片相关信息</strong>，所以要避免这中问题，就需要设置图片的crossorigin属性，当然服务端也需要设置响应头。</p><h3 id="三.浏览器缓存">三.浏览器缓存 <a href="#三.浏览器缓存">#</a></h3><p>我在查阅了很多资料后，image的crossorigin属性也设置了，一般应该是没有问题了，但是浏览器还是报错，图片跨域！！！</p><p>整个人快整懵了，崩溃了。后来发现罪魁祸首是浏览器缓存导致的。因为我在css样式中提前引入了非同源地址的图片作为背景图，代码类似如下：</p><pre><code class="hljs language-css">{
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">"http://www.example.com/1.jpg"</span>);
}
</code></pre><p>背景图的url与当前网站是非同源的，css在请求的时候是以普通请求（非cors方式）请求的，所以请求到的图片是污染的图片，在canvas中直接使用后，肯定是不能获取该图片数据的（getImageData、toBlob和toDataURL方法报错）。虽然我在canvas中使用的图片已经设置过了crossorigin属性但是其地址也是<code>http://www.example.com/1.jpg</code>，与我上面用到的背景图地址相同，<strong>谷歌浏览器为了用户体验，直接使用缓存的图片</strong>，也就是背景图，但是这背景图是以非同源方式请求的啊。这下该怎么办。我又不能设置css背景图以cors方式请求，html并没有提供类似的corssorigin属性来设置background image。所以要么我更改背景图片，要么另寻他法。</p><h3 id="四.解决">四.解决 <a href="#四.解决">#</a></h3><p>发现了问题，就要去解决。在查找了大量的资料，最后找到了一个方法，就是在每次请求图片的时候加一个timestamp参数，这样可以强制浏览器不使用缓存的图片。每次在canvas上绘制图片时，重新请求的图片地址加上当前的时间戳参数。</p><pre><code class="hljs language-js"><span class="hljs-string">`http:://www.example.com/1.jpg?timestamp=<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>
</code></pre><p>因为每次请求的地址不一样，所以浏览器不可能在从缓存中找到它认为相同的图片了。至此问题终于被解决了😄。</p><p>(完)</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/algorithm-math/binaryTree-traverse">上一篇：二叉树—已知二叉树的前序遍历和中序遍历，输出二叉树</a></span><span class="next-article"><a href="/blogs/react/mistery-of-react-hook">下一篇：揭开react hook的神秘面纱</a></span></div></div><div class="footer"><span>@2020-2023 Wang Pengfei</span><a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index">皖ICP备2021002453号-1</a></div></body></html>