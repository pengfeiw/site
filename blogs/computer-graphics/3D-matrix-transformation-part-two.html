<html lang="zh_cn"><head><title>3D图形学中的矩阵变换（二） | WANG_PF.OS.BLOGS</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="你是如何看待线性变换矩阵的，本篇文章主要介绍矩阵变换中的基变换及自己的理解，简要介绍lookAt矩阵的证明思路。"><link rel="stylesheet" href="/blogs/assests/style/code_github.css"><link rel="stylesheet" href="/blogs/assests/style/markdown.css"><link rel="stylesheet" href="/blogs/assests/style/article.css"><link rel="stylesheet" href="/blogs/assests/style/navigator.css"><link rel="stylesheet" href="/blogs/assests/style/global.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){const t=document.getElementById("search-input");t.addEventListener("keydown",function(e){"Enter"===e.key&&t.value&&window.open(`https://bing.com/search?q=${t.value}%20site%3A+pengfeixc.com`,"_blank")}),document.querySelectorAll(".markdown-body pre").forEach(function(t){var e=document.createElement("div");e.className="code-block-wrapper",t.parentNode.insertBefore(e,t),e.appendChild(t);const n=document.createElement("button");n.className="code-copy-btn",e.appendChild(n),n.addEventListener("click",async function(){var e=t.querySelector("code");if(e)try{await navigator.clipboard.writeText(e.textContent),n.classList.add("copied"),setTimeout(function(){n.classList.remove("copied")},2e3)}catch(e){console.error("Failed to copy:",e)}})})})</script></head><body><div class="header"><div class="navigator"><div class="nav-sections"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div class="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="rss"><a href="/blogs/rss.xml">RSS</a></div><div class="search-wrapper"><input id="search-input" type="search" placeholder="search"></div></div></div></div><div class="body"><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年5月29日</span><span class="category"><a href="/blogs/computer-graphics">标签：Computer Graphics</a></span></div><div class="markdown-body"><h1 id="3D图形学中的矩阵变换（二）">3D图形学中的矩阵变换（二） <a href="#3D图形学中的矩阵变换（二）">#</a></h1><p>在之前的一篇文章中，我介绍了平移、旋转和缩放矩阵的证明，简单的讲解了如何证明绕任意轴旋转的旋转矩阵的证明思路。没有看过的朋友可以在<a href="https://pengfeixc.com/blog/60a7492be97367196dce3eef">这里</a>看到。</p><p>这篇文章主要讲解下我理解的矩阵和矩阵的基变换，并简单介绍下<strong>LookAt</strong>矩阵。</p><h3 id="一. 摄像机">一. 摄像机 <a href="#一. 摄像机">#</a></h3><p>这里涉及到三维图形学中的<strong>摄像机</strong>的概念。大家肯定都玩过游戏，现在游戏发展速度都特别快，很多游戏世界都是3D的，例如国外的荒野大镖客、巫师以及国内最近比较火的原神。游戏世界中所有的物体，例如桌子、树木、动物以及交通工具等等，它们在游戏世界中都有一个特定的位置，这个位置就是它们在游戏世界中的坐标，我们把它们在游戏世界中的位置称为<strong>世界坐标</strong>。假如同时有两个玩家A和B在游戏世界中漫游，那么这两个玩家的屏幕肯定显示的是不一样的，因为玩家在世界坐标系中的位置（世界坐标）不一样，并且视线的方向也不同，所以他们看到的屏幕肯定是不一样的。这里的A和B玩家，其实就是摄像机。假设我们以摄像机（玩家）为原点创建一个新的坐标系，可以称它为<strong>摄像机坐标系（观察空间坐标系）</strong>。那么同样的物体在世界坐标系中坐标为（300，200），那么它用摄像机坐标系如何表示呢？我用二维图形描述下这个问题。</p><p><img src="https://pengfeiw.github.io/images/blog/23.jpg" alt="image-20210526223206977"></p><p>假设平面中有一点A，此时点A的坐标为(1, 1)，表示A点在如图所示的坐标系中在原点右侧1个单位，上方1个单位。如果将这个坐标系旋转45度，变成另一个坐标系X2Y2，那么在新的坐标系X2Y2中如何表示A点呢？</p><p><img src="https://pengfeiw.github.io/images/blog/24.jpg" alt="image-20210526224510669"></p><p>旋转45度，很容易计算出来A点在X2Y2坐标系中的坐标为(√2, 0)。那么有没有一个矩阵<strong>A</strong>可以使得<strong>A</strong>·P1 = P2，也就是经过矩阵A的变换，P1坐标变成了P2。这里P1表示在原来的坐标系中的坐标，P2表示在新的坐标系中同一个点的坐标表示。其实这里的<strong>A</strong>就是本篇文章要讨论的lookAt矩阵。</p><p>LookAt矩阵的作用就是，将世界坐标系中的物体坐标转换为用摄像机坐标系统描述，说白了就是在不同坐标系中描述同一个位置。</p><p>下面是learnopengl_cn官网给出的解释：</p><blockquote><p>当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。</p></blockquote><h3 id="二. 深入线性变换矩阵">二. 深入线性变换矩阵 <a href="#二. 深入线性变换矩阵">#</a></h3><p>首先我给大家讲述一个很重要的事实，在我上篇文章中说的几个变换矩阵，<code>线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示</code>，即<strong>i帽、j帽和k帽</strong>。请牢牢记住这一重要特性，因为这一个特性真的很重要，它会直接影响你的线性代数的思维。你可能现在还没有认识到这一特征，没关系，请继续阅读。</p><p><img src="https://pengfeiw.github.io/images/blog/25.jpg" alt="image-20210529095906096"></p><p>还是以之前的A点的例子为例，来说明这一思想。A点坐标是(1, 1), 向量OA也是(1, 1)，用<strong>i帽</strong>和<strong>j帽</strong>表示的话<strong>OA = 1 * i + 1 * j</strong>。</p><p><img src="https://pengfeiw.github.io/images/blog/26.jpg" alt="image-20210529100455563"></p><p>此时，我们将坐标系旋转45度，变成下图所示。这里我顺便小小的提一下，线性变换就是保证我画的网格线平行且等距分布，这也是为什么我会画一些网格在图中，上一篇文章讲解的几个变换矩阵都是线性变换。</p><p><img src="https://pengfeiw.github.io/images/blog/27.jpg" alt="image-20210529101044826"></p><p>正是因为是线性变换，所以变换后的A点满足如下公式：<strong>OA</strong> = 1 * <strong>i2</strong> + 1 * <strong>j2</strong>。因为旋转45度，所以我们计算出<strong>i2</strong>和<strong>j2</strong>分别为(√2 / 2, √2 / 2)和(-√2 / 2, √2 / 2)。所以<strong>OA</strong> = (0, √2 )。</p><p><img src="https://pengfeiw.github.io/images/blog/28.jpg" alt="image-20210529102434851"></p><p>请仔细阅读我上图中的计算步骤，请保证你能看懂整个计算过程。</p><p>上图中我写了一个变换矩 阵，这个变换矩阵其实就是我们旋转45度的旋转矩阵。细心的朋友已经发现了，矩阵的第一列就是变换后的i帽，第二列就是变换后的j帽。所以还记得我之前说的那个真理吗？</p><p><code>线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示</code>。</p><h3 id="三.逆矩阵">三.逆矩阵 <a href="#三.逆矩阵">#</a></h3><p>还是用之前的例子，我们将变换前的坐标系称为xyo, 变换后的坐标系称为x2y2o。xyo-&gt; x2y2o的变换矩阵如下（后面我将其称为<strong>MatA</strong>），每一列表示的是x2y2o坐标系的x和y方向的单位向量在xyo坐标系中的表示。所以将这个矩阵乘以一个坐标，其实得到的是一个在xyo坐标系中表示的坐标。</p><p><img src="https://pengfeiw.github.io/images/blog/29.jpg" alt="image-20210529105350442"></p><p>例如，例如点<strong>A(1, 1)</strong>，计算<strong>MatA · A = B</strong>,得到的点<strong>B</strong>是经过线性变换后<strong>A</strong>的坐标，但是这个坐标还是用xyo坐标系表示的， 点<strong>A</strong>的坐标却是在x2y2o坐标系中的表示。所以这里<strong>MatA</strong>的作用就是将x2y2o坐标系的表示转化为xyo坐标系表示。那么反过来呢，xyo -&gt; x2y2o如何转换？</p><p>这里引入逆矩阵的思想，逆矩阵表示相反的线性变换， 由<strong>MatA · A = B</strong>得到 <strong>A = （MatA^-1) · B ** ， <strong>MatA^-1</strong> 表示的是</strong>MatA<strong>的逆矩阵。所以有</strong>MatA · A = B<strong>和</strong>A = （MatA^-1) · B**这两个公式，就可以得到同一点在xyo和x2y2o中的表示方法。</p><p>这不正是lookAt矩阵的作用吗？lookAt矩阵就是在不同坐标系下如何表示同一点。</p><h3 id="四.lookAt矩阵">四.lookAt矩阵 <a href="#四.lookAt矩阵">#</a></h3><p>其实这部分类容已经不重要了，因为通过上面的学习，你已经知道如何去转换坐标系了。但是我还是简单的介绍下learnOpengl_cn官网的lookAt矩阵吧。</p><p>LookAt矩阵如下， (Rx, Ry, Rz)表示摄像机的X轴方向向量，(Ux, Uy, Uz)表示摄像机坐标系的Y轴方向，(Dx, Dy, Dz)表示摄像机的视线方向及Z轴。 (Px, Py, Pz)表示摄像机位置的世界坐标。</p><p><img src="https://pengfeiw.github.io/images/blog/30.jpg" alt="image-20210526213813353"></p><p>通过上面的阅读，现在看这个矩阵，你能否自己给出证明呢?</p><p>......</p><p>......</p><p>矩阵的第二部分，是一个平移矩阵，目的是平移到(px, py, pz)，矩阵中px,py,pz都加上了负号，是因为这里移动的不是摄像机而是整个场景，将场景向相反方向移动等价于移动摄像机。矩阵的第一部分就是一个线性变换的逆矩阵。计算逆矩阵通常需要计算非逆矩阵，那么非逆矩阵是什么呢？我在第二节内容说到，<strong>线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示</strong>。所以由 (Rx, Ry, Rz), (Ux, Uy, Uz), (Dx, Dy, Dz), 我们很容易写出线性变换矩阵。</p><p><img src="https://pengfeiw.github.io/images/blog/31.jpg" alt="image-20210529111854626"></p><p>这个线性变换矩阵我用<strong>Mat1</strong>表示，平移矩阵用<strong>Mat2</strong>表示，所以lookAt矩阵如下：</p><p><strong>LookAt = (Mat1^-1) · Mat2</strong>。</p><p>逆矩阵的计算并不重要，写代码时，一般可以直接用函数去求解逆矩阵，重要的是你要理解我在本篇文章介绍的思想。本篇文章可能不是很好理解，我已经把我理解的尽可能详细的去描述讲解出来了，你可以多读几遍，带入思考去阅读。</p><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/computer-graphics/3D-matrix-transformation-part-one">上一篇：3D图形学中的矩阵变换（一）</a></span><span class="next-article"><a href="/blogs/computer-graphics/3D-matrix-transformation-part-three">下一篇：3D图形学中的矩阵变换（三）</a></span></div></div><div class="toc"><div class="toc-header">目录</div><div class="toc-body"><div class="toc-item"><a class="toc-item-link" href="#3D图形学中的矩阵变换（二）" style="padding-left:15px">3D图形学中的矩阵变换（二）</a></div><div class="toc-item"><a class="toc-item-link" href="#一. 摄像机" style="padding-left:45px">一. 摄像机</a></div><div class="toc-item"><a class="toc-item-link" href="#二. 深入线性变换矩阵" style="padding-left:45px">二. 深入线性变换矩阵</a></div><div class="toc-item"><a class="toc-item-link" href="#三.逆矩阵" style="padding-left:45px">三.逆矩阵</a></div><div class="toc-item"><a class="toc-item-link" href="#四.lookAt矩阵" style="padding-left:45px">四.lookAt矩阵</a></div></div></div></div></body></html>