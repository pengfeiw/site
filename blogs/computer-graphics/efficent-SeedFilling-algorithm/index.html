<html lang="zh_cn"><head><title>高效率种子填充算法</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="高效率种子填充算法的实现"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.png" alt="rss"></a></div></div></div><a href="/blogs/"><img src="/blogs/assests/images/icon.jpg"></a></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年6月21日</span><span class="category"><a href="/blogs/computer-graphics">标签：ComputerGraphics</a></span></div><div class="markdown-body"><h1 id="高效率种子填充算法">高效率种子填充算法 <a href="#高效率种子填充算法">#</a></h1><p>最近写了一个画板小程序，为了实现画板的填充功能，研究了一下图形学填充算法。我在网上查找了大量的资料，最终找到了一个效率很高的填充算法。可以在<a href="https://pengfeiw.github.io/minicode/react-paint">minicode</a>看到我的画板程序，测试下填充功能的速度。</p><p>下面我将讲述我的算法实现过程。</p><h3 id="一. 种子填充算法（flood fill or seed fill）">一. 种子填充算法（flood fill or seed fill） <a href="#一. 种子填充算法（flood fill or seed fill）">#</a></h3><p>网上有很多讲解种子填充算法的，大家一搜就知道有4联通的方式和8联通的方式。但是4联通和8联通的算法效率太低了，根本无法用来实现画板的填充功能。 4联通的算法，我简单描述一下：</p><ol><li>从一个像素点出发，将其入栈。</li><li>处理栈顶的像素点，弹栈。</li><li>判断这个像素点的上、下、左、右的4个像素点是否满足填充要求，若满足将其染色，并入栈。</li><li>继续弹栈，重复2和3步骤，直至栈为空。</li></ol><p>8联通算法与4联通算法同理。 至于它们的代码，比较简单，我就偷懒不写出来了。</p><h3 id="二. 高效率的填充算法（efficient flood fill）">二. 高效率的填充算法（efficient flood fill） <a href="#二. 高效率的填充算法（efficient flood fill）">#</a></h3><p>这个算法是我在一篇文章中看到的，我不知道这个算法是谁想出来的，但是它的效率经过我的实践确实很高，满足我的要求。 填充算法的目标是用新的填充颜色填充所有与起始像素相连的同颜色的像素。假设有如图3x4的像素块，填充起始点在(1,3)。创建一个栈，将起始点入栈。</p><p><img src="https://pengfeiw.github.io/images/blog/56.png" alt="flood-fill"></p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> pixelStack = [[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]];
</code></pre><p>接下来执行弹栈操作，栈顶元素为(1, 3)，也就是起始点。我们从这个点开始向上走，直到走到边界或者与起始点颜色不同的像素点时停止。</p><p><img src="https://pengfeiw.github.io/images/blog/57.png" alt="flood-fill"></p><p>然后再回头向下开始，填充颜色，首先将(1, 0)点填充为红色并设置两个布尔变量reachLeft和reachRight为false。</p><p><img src="https://pengfeiw.github.io/images/blog/58.png" alt="flood-fill"></p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> reachLeft = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">var</span> reachRight = <span class="hljs-literal">false</span>;
</code></pre><p>这时判断其左边的像素点是否与起始点颜色相同，如果相同，将左侧像素点入栈并将reachLeft设置为true。因为此时右边为黑色，与起始点颜色不一样，所以不需要将右边的像素入栈。</p><p><img src="https://pengfeiw.github.io/images/blog/59.png" alt="flood-fill"></p><pre><code class="hljs language-javascript">reachLeft = <span class="hljs-literal">true</span>;
</code></pre><p>继续向下走，将下面一个像素染成红色。</p><p><img src="https://pengfeiw.github.io/images/blog/60.png" alt="flood-fill"></p><p>此时因为reachLeft为true，reachRight为false，所以左侧不需要判断，只需要判右侧是否满足填充像素的要求，可以看到右侧像素点与起始点像素颜色相同，所以将其入栈，并将reachRight设置为true。</p><p><img src="https://pengfeiw.github.io/images/blog/61.png" alt="flood-fill"></p><pre><code class="hljs language-javascript">reachRight = <span class="hljs-literal">true</span>;
</code></pre><p>继续，此时左侧为黑色方块与起始点像素色颜色不同，我们将reachLeft重置为false。</p><p><img src="https://pengfeiw.github.io/images/blog/62.png" alt="flood-fill"></p><pre><code class="hljs language-javascript">reachLeft = <span class="hljs-literal">false</span>;
</code></pre><p>继续将下一个像素点染色。</p><p><img src="https://pengfeiw.github.io/images/blog/63.png" alt="flood-fill"></p><p>此时，其左侧像素(0, 3)与起始颜色相同，并且reachLeft为false，所以将(0, 3)入栈。</p><p><img src="https://pengfeiw.github.io/images/blog/64.png" alt="flood-fill"></p><p>继续染色，直到到达边界或者下一个像素点颜色与起始点颜色不同。</p><p><img src="https://pengfeiw.github.io/images/blog/65.png" alt="flood-fill"></p><p>这样一轮染色就完成了，我们需要继续弹栈直至清空栈内元素，所以接下来从(0, 3)开始，重复上述过程。</p><p><img src="https://pengfeiw.github.io/images/blog/66.png" alt="flood-fill"></p><p>下图是接下来所有的染色过程。</p><p><img src="https://pengfeiw.github.io/images/blog/67.png" alt="flood-fill"></p><p>一个更复杂的例子：</p><p><img src="https://pengfeiw.github.io/images/blog/68.gif" alt="flood-fill"></p><h3 id="三.代码">三.代码 <a href="#三.代码">#</a></h3><p>可以在我的画板程序中的colorFill.ts文件中找到我的实现代码。</p><p>画板：<a href="https://github.com/pengfeiw/react-paint">https://github.com/pengfeiw/react-paint</a> 。</p><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/minicode/react-paint-tool">上一篇：react实现简易画板程序</a></span><span class="next-article"><a href="/blogs/minicode/minicode-introduction">下一篇：MINICODE</a></span></div></div></body></html>