<html lang="zh_cn"><head><title>递归—台阶问题 | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="以走台阶的例子，说明递归算法思想。"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="body"><div class="nothing"></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年4月2日</span><span class="category"><a href="/blogs/algorithm-math">标签：Algorithm/Math</a></span></div><div class="markdown-body"><h1 id="递归">递归 <a href="#递归">#</a></h1><h3 id="一. 递归的含义">一. 递归的含义 <a href="#一. 递归的含义">#</a></h3><blockquote><p>递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">维基百科</a>有几个语言例子，我觉得挺有意思：</p><blockquote><ol><li>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</li><li>一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到：“一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到：‘一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到……’”</li><li>大雄在房里，用时光电视看着从前的情况。电视画面中的那个时候，他正在房里，用时光电视，看着从前的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着从前的情况……</li></ol></blockquote><p>可以看出<strong>递归实际就是循环，不过是程序一遍又一遍的调用自身，然后递归程序必须有一个退出循环的条件</strong>，否则就会导致死循环。</p><h3 id="二.走楼梯">二.走楼梯 <a href="#二.走楼梯">#</a></h3><p>有一个经典的算法题，问一个10级台阶的楼梯，如果每次只能走一个台阶或者两个台阶，那么有多少种走法？ 很多人看过很多次这种题目，所以很快的写出如下答案：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">solution</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">solution</span>(n - <span class="hljs-number">2</span>);
}

<span class="hljs-title function_">solution</span>(<span class="hljs-number">10</span>);
</code></pre><p>该解法，就用了递归的思想，因为一个人每走一次，有两种走法，可以走两个台阶，也可以走一个台阶。所以在n台阶上，他前一步可能在n-1台阶上，也可能在n-2台阶上。假设要到达n-1台阶上，有solution(n-1)种走法，到达n-2台阶有solution(n-2)种走法，那么到达n台阶，有solution(n-1) + solution(n-2)种走法。</p><p>注意我上面的解答给出了递归终止点：</p><pre><code class="hljs language-javascript">    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
</code></pre><p>如果没有这两句，程序将会进入死循环，导致内存溢出。</p><p>相信大家在看到题目时，都会很容易的写出上面的答案，但是上面的解法效率并不高。</p><h3 id="三.正向解法">三.正向解法 <a href="#三.正向解法">#</a></h3><p>上面的走楼梯有没有更好的解法呢？能不能优化算法的效率呢？请仔细想一想。</p><p>如果我们分析solution(n-1)+solution(n-2)的递归树，会发现里面有大量的重复计算，时间复杂度是以n的指数增长的。我们以solution(5)为例：</p><p><img src="https://pengfeiw.github.io/images/blog/5.jpg" alt="台阶算法递归树"></p><p>可以看到solution(3)需要重复两次计算，solution(2)需要重复3次，solution(1)重复两次。</p><p>我们将上面的解法，反过来求解，先求s1，在求s2，在通过s1和s2求s3，然后依次求s4、s5...这样算法的复杂度为n。然后我们可以写出如下代码：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, index = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">while</span>(index &lt; n) {
        <span class="hljs-keyword">var</span> tem = a;
        a = b;
        b = tem + b;
        index++;
    }
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/algorithm-math/singleLinkedList">上一篇：单链表—找到链表中倒数第k个结点</a></span><span class="next-article"><a href="/blogs/algorithm-math/binary-array-search">下一篇：数组—二维数组中的查找</a></span></div></div><div class="toc"><div class="toc-header">目录</div><div class="toc-body"><div class="toc-item"><a class="toc-item-link" href="#递归" style="padding-left:15px">递归</a></div><div class="toc-item"><a class="toc-item-link" href="#一. 递归的含义" style="padding-left:45px">一. 递归的含义</a></div><div class="toc-item"><a class="toc-item-link" href="#二.走楼梯" style="padding-left:45px">二.走楼梯</a></div><div class="toc-item"><a class="toc-item-link" href="#三.正向解法" style="padding-left:45px">三.正向解法</a></div></div></div></div></body></html>