<html lang="zh_cn"><head><title>整数反转 | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0."><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年9月16日</span><span class="category"><a href="/blogs/algorithm-math">标签：algorithm</a></span></div><div class="markdown-body"><h1 id="整数反转（Reverse Interger）">整数反转（Reverse Interger） <a href="#整数反转（Reverse Interger）">#</a></h1><h2 id="一.题目">一.题目 <a href="#一.题目">#</a></h2><p>这个题目是leetcode上的一道算法题，题目如下。</p><blockquote><p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0. <strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p></blockquote><blockquote><p>翻译：给一个有符号的32位整数，返回它的数字反转后的整数。如果反转后的数值溢出，即超出了32位整数范围[-2^31, 2^31 - 1]，返回0。 限制：不允许存储64位整数。</p></blockquote><p>例如：</p><pre><code>Input: x = 123
Output: 321
</code></pre><pre><code>Input: x = -123
Output: -321
</code></pre><h2 id="二.分析">二.分析 <a href="#二.分析">#</a></h2><p>最近一年我都在从事JavaScript的工作，C++、C#接触少了，所以看到这种题目，突然有一种陌生感。这个算法题目原本就是为强类型语言程序员设计的，如果是没有接触过强类型语言（C++、C#、Java等）的JavaScript程序员看到这种题目，也许题目都看不大懂。</p><p>首先解释下一些概念。</p><ul><li><p><strong>signed</strong>: 符号，强类型语言中，数值类型都分为有符号和无符号两种，有符号数的二进制最后一位存储的是符号位，在这道题目中你不需要关心二进制的符号位，只需要知道题目表示的是正负整数。</p></li><li><p><strong>32-bit</strong>: int类型是4字节的，一个字节占8位，所以32-bit的整数范围为[-2^31, 2^31 - 1]，即[-2147483648, 2147483647]。</p></li></ul><p>假设有输入1111111119，反转整数为9111111111，结果超出了32-bit整数范围，所以应该返回0。</p><p>题目还限制不允许使用64位整数，所以不允许使用long类型（long类型是8个字节，64位）数值。</p><p>如果不考虑题目限制，可以很自然的写出如下解法：</p><pre><code class="hljs language-c++"><span class="hljs-comment">// c++，使用了long类型，不符合题意</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) {
            result = <span class="hljs-number">10</span> * result + x % <span class="hljs-number">10</span>;
            x /= <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">return</span> (result &gt; INT_MAX || result &lt; INT_MIN) ? <span class="hljs-number">0</span> : res;
    }
};
</code></pre><p>令我惊讶的是，上面的题目竟然通过了，leetcode并没有检测是否使用了long类型。</p><h2 id="三.最佳解法">三.最佳解法 <a href="#三.最佳解法">#</a></h2><p>上面的解法使用了long类型数据，显然不符合题意。在网上找到了另一种解法，如下：</p><pre><code class="hljs language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(res) &gt; INT_MAX / <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;
            x /= <span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</code></pre><p>与第一种解法很相似，但是没有用到long类型。它用了一种很巧妙的方法，避免了使用long类型。</p><p>通过<code>abs(res) &gt; INT_MAX / 10</code>，检测结果是否溢出。为什么可以使用这种方式呢？</p><p>首先，输入的整数<code>x</code>也是一个32-bit整数，所以范围应该在[-2147483648, 2147483647]内。分以下两种情况讨论：</p><ul><li><code>x</code>位数等于10位：那么<code>x</code>的第一位只能为1或者2，反转后的值（不包含正负号）为<code>xxxxxxxxx1</code>和<code>xxxxxxxxx2</code>。</li><li><code>x</code>位数小于10位：那么反转后的值肯定也在32-bit范围内，直接返回反转后的值。</li></ul><p>当<code>x</code>位数等于10位时，设反转后的值为<code>rx</code>，我们只需要判断<code>abs(rx / 10) &gt; INT_MAX / 10</code>即可判断数值是否溢出，因为<code>rx</code>个位数值只可能为1或者2，不需要判断。</p><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/javascript/tsconfig">上一篇：【TypeScirpt】详解tsconfig.json文件</a></span><span class="next-article"><a href="/blogs/javascript/babel-tutorial">下一篇：Babel入门教程</a></span></div></div><div class="footer">@2020-2023 Wang Pengfei</div></body></html>