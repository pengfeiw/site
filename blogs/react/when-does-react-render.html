<html lang="zh_cn"><head><title>React组件何时重渲染 | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords"><meta name="description" content="译文：主要从原理上讲述React重渲染机制，说明virtual dom和native dom等相关概念，并描述了render函数何时执行。"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="body"><div class="nothing"></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年7月2日</span><span class="category"><a href="/blogs/react">标签：React</a></span></div><div class="markdown-body"><h1 id="React组件何时重渲染">React组件何时重渲染 <a href="#React组件何时重渲染">#</a></h1><p>本篇文章是一篇译文。</p><table><thead><tr><th>原文</th><th><a href="https://felixgerschau.com/react-rerender-components/">When does React re-render components?</a></th></tr></thead><tbody><tr><td>作者</td><td><a href="https://felixgerschau.com/about/">Felix</a></td></tr><tr><td>翻译</td><td><a href="http://www.pengfeixc.com">Wang Pengfei</a></td></tr></tbody></table><p><img src="https://felixgerschau.com/static/842abf1755973a529d07d53b14603d80/5a190/react-rerender-thumbnail.png" alt="React组件何时重渲染"></p><p>众所周知，React通过只更新变化的UI界面，给用户提供了一个效率很高体验。</p><p>当深入研究React渲染机制，有一些术语概念比较难以理解。很长一段时间内，我不清楚VDOM是什么或者说React是如何决定去重渲染组件的。</p><p>在这篇文章的第一部分，我将会解释与React渲染相关的一些比较重要的概念，并且讲清楚React是如何决定去渲染一个组件的。</p><p>在文章的最后，我将会告诉你如何去组织优化你的React应用，来提高效率。</p><p>如果，读了这篇文章之后，你有一些问题或者发现了一些错误，你可以在文章下方留言或者给我发邮件。</p><p><strong>目录</strong></p><ul><li>React的渲染<ul><li>什么是渲染</li><li>什么是虚拟树(VDOM)？</li><li>这对效率意味着什么？</li><li>如何在实际中看到重渲染过程？</li></ul></li><li>React何时执行重渲染？<ul><li>当组件props发生改变时，为什么组件不更新？</li></ul></li><li>强制React组件重新渲染<ul><li>使用React的<code>forceUpdate</code>函数</li><li>在React hooks中强制更新组件</li></ul></li><li>总结</li></ul><h2 id="React的渲染">React的渲染 <a href="#React的渲染">#</a></h2><h3 id="什么是渲染">什么是渲染 <a href="#什么是渲染">#</a></h3><p>如果我们想要理解React是如何渲染的，重渲染是如何工作的，那么最好的方法是取理解react在背后做了哪些事。</p><p>渲染是一个可以在不同抽象层级上理解的术语。不同场景下，它有着不同的含义。但是最终无论在任何场景下，它都被描述为生成一个图片的过程。</p><p>但是首先，我们必须去理解文档对象模型(DOM, Document Object Model)是什么：</p><blockquote><p>"The W3C Document Object Model (DOM) is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document."</p></blockquote><p>用白话来说，DOM就是当你打开一个网页，你在屏幕上看到的任何东西，这些东西都是通过标记语言HTML表达的。</p><p>浏览器允许JavaScript语言通过API修改DOM: 全局<code>document</code>对象代表了HTML DOM的状态，并且为用户（程序员）提供了一些可以修改DOM的函数接口。</p><p>你可以使用JavaScript通过DOM编程接口去修改DOM，例如<code>document.write</code>、<code>Node.appendChild</code>和<code>Element.setAttribute</code>等函数。</p><h3 id="什么是虚拟树(VDOM)？">什么是虚拟树(VDOM)？ <a href="#什么是虚拟树(VDOM)？">#</a></h3><p>React提供了另外一个DOM树，叫做<strong>虚拟树（VDOM, virtual dom）</strong>, 它是基于DOM的另一个抽象层级。它由React应用元素组成。</p><p>一个React应用的state发生改变，首先会被应用于VDOM。如果VDOM的新state改变触发了UI的改变，ReactDOM库会通过只更新需要更新的部分来高效的去更新界面。</p><p>例如，如果只有一个元素的属性（attribute）发生了改变，React将会通过<code>document.setAttribute</code>（或者其他类似的东西）只更新Html元素的的属性。</p><p><img src="https://felixgerschau.com/static/a8c4277dd79350b5621add534576cfcd/5a190/react-rerender-vdom.png" alt="virtual dom"></p><p><i>红色的点表示DOM树的更新。更新VDOM并不会触发真实DOM的更新。</i></p><p>当VDOM更新时，React将会比较此时的VDOM和之前的VDOM的快照。如果没有发生变化，真实的DOM不会改变。<strong>将新的VDOM与旧的VDOM比较的过程，称之为对比（diffing）</strong>。</p><p>由于真实的DOM更新会触发界面的重绘，所以真实的DOM更新是非常缓慢的。React通过减少更新的机会，大大提高了DOM更新的效率。</p><p><strong>因此，我们必须认识到原生DOM与虚拟DOM更新的差异</strong>。</p><blockquote><p>想要了解更多关于它们是如何工作的，请阅读react的相关文档<a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a>。</p></blockquote><h3 id="这对效率意味着什么？">这对效率意味着什么？ <a href="#这对效率意味着什么？">#</a></h3><p>当我们讨论React的渲染时，我们通常讨论的是render函数，它们并不总是触发一个界面UI的更新。</p><p>让我一起看一个例子：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Tile</span> <span class="hljs-attr">message</span>=<span class="hljs-string">{message}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Tile</span> /&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span></span>
    );
};
</code></pre><p><i>在函数组件中,函数的执行等价于类组件中render函数的执行。</i></p><p>当父组件的state发生改变时(在这个例子中是<code>App</code>), 两个<code>Title</code>组件将会重新渲染（re-render），即使第二个没有接受任何属性（props）。 这使<code>render</code>函数被调用三次，但是实际的DOM修改仅在第一个<code>Title</code>组件中产生。 <img src="https://felixgerschau.com/static/3221cabdf6bdab6681a6512252dd7e00/5a190/react-rerender-vdom-comparison.png" alt="VDOM与DOM"></p><p><i>红色的点表示渲染。在React中，这意味着render函数执行。在真实DOM中，这意味着UI的重绘。</i></p><p>有一个好消息是你并不需要为界面的重绘的效率担心太多，React早已为你优化了很多，提高了效率。</p><p>坏消息是：<strong>所有这些左侧的红色点意味着这三个组件的render函数都执行了。</strong></p><p>这些render函数执行有两个缺点：</p><ol><li>React必须去执行它的diffing算法，来检查这些组件是否需要更新UI。</li><li>所有的这些render函数或者函数组件中的代码都将再次执行。</li></ol><p>第一点存在争议，但是这并不重要，因为React已经非常高效的去做了这件事。危险存在于你写的那部分代码在每次React渲染时都重复执行了。</p><p>在上面的例子中，我们有一个小的组件树。但是想像一下，如果每一个结点都有许多的孩子结点，并且这些孩子结点都可能拥有它们的子组件时，会发生什么。我们将看到我们如何去优化这些。</p><h3 id="如何在实际中看到重渲染过程？">如何在实际中看到重渲染过程？ <a href="#如何在实际中看到重渲染过程？">#</a></h3><p>React开发者工具，可以在<i>Components -&gt; View Settings -&gt; Highlight updates when components render</i>中可以设置高亮渲染。这会使用看到<strong>虚拟渲染（ virtual renders）</strong>。</p><p>如果你想看到<strong>原生渲染（native re-renders）</strong>，你可以在谷歌开发者工具中设置：<i>dot menu on the right -&gt; More tools -&gt; Rendering -&gt; Paint flashing</i>。</p><p>现在点击你的app，首先React重渲染高亮，接着原生渲染，并且<strong>你会看到React做了多少优化渲染的工作</strong>。<video src="https://felixgerschau.com/video/chrome-devtools-paint-flashing.mp4" width="100%" controls="controls" type="video/mp4">Sorry, your browser doesn't support embedded videos.</video></p><h2 id="React何时执行重渲染？">React何时执行重渲染？ <a href="#React何时执行重渲染？">#</a></h2><p>在之前，我们看到了什么导致了UI的重绘，但是React组件的渲染函数是什么时候执行的呢？</p><p>React计划每次渲染执行都是在<strong>组件的状态</strong>发生改变时。</p><p>计划一次渲染意味着render函数并不是立即执行的。React将会寻找一个最佳时机。</p><p>改变状态意味着React会触发一个更新，当我们调用<code>setState</code>函数时（在React hook中，使用<code>useState</code>）。这不仅仅意味着组件的render函数将会执行，同样意味着，它的子组件都将执行，无论它们的props是否发生改变。</p><p>如果你的app缺少一个合理的结构，那么运行时与你的期望相比可能会执行更多的javascript代码，因为更新一个父节点也意味着执行它所有的子节点的render函数。</p><p>在文章的最后一个部分，我们将看到一些建议，它会帮助你提前阻止这些情况的发生。</p><h3 id="当组件props发生改变时，为什么组件不更新？">当组件props发生改变时，为什么组件不更新？ <a href="#当组件props发生改变时，为什么组件不更新？">#</a></h3><p>当一个组件的props改变时，但是组件并不更新可能有两点原因：</p><ol><li><code>setState</code>没有以正确的方式更新props。</li><li>prop的引用的对象最终是一样的。</li></ol><p>正如我们之前看到的那样，当你调用<code>setState</code>函数去改变一个state时（或者在函数组件中通过<code>useState</code>hook,提供了一个函数）React将会重新渲染组件。</p><p>最终结果是，因此，当父组件的状态通过这些函数之一发生变化时，子组件才会更新。</p><p><strong>直接改变这些props对象是不被允许的</strong>，因为这并不会触发任何改变，React不会注意到这些变化。</p><pre><code class="hljs language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'Felix'</span>;
</code></pre><p><i>不要做这种事！</i></p><p>你可以在父组件中这样更新state，而不是像上面那样更新子组件的props：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Parent</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Felix'</span> });
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleInput</span> = (<span class="hljs-params">e</span>) =&gt; {
        e.<span class="hljs-title function_">preventDefault</span>();
        <span class="hljs-title function_">setUser</span>({
        ...user,
        <span class="hljs-attr">name</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>,
        });
    };

    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleInput}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{user.name}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span></span>
    );
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = (<span class="hljs-params">{ user }</span>) =&gt; (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
);
</code></pre><p><i>通过相应的React函数去更新state是很重要的。你可以在这里找到<a href="https://codepen.io/fgerschau/pen/MWybNbY">Codepen&nbsp;demo</a></i>。</p><p>注意我是如何通过<code>setUser</code>更新state的，它是我通过useState钩子获得的。在class组件中与<code>this.setState</code>是等价的。</p><h2 id="强制React组件重新渲染">强制React组件重新渲染 <a href="#强制React组件重新渲染">#</a></h2><p>在我进行React相关React工作的这两年里，我从来没遇到过需要强制组件更新的情况。如果你阅读这篇文章的目的是想要强制更新组件，我强烈建议你从文章的开头读这篇文章，因为通常会有一个更好的方式去处理这些没有更新的组件。</p><p>然而，如果你真的需要去强制更新一个组件，你可以使用如下方式：</p><h3 id="%E4%BD%BF%E7%94%A8React%E7%9A%84%3Ccode%3EforceUpdate%3C/code%3E%E5%87%BD%E6%95%B0">使用React的<code>forceUpdate</code>函数 <a href="#%E4%BD%BF%E7%94%A8React%E7%9A%84%3Ccode%3EforceUpdate%3C/code%3E%E5%87%BD%E6%95%B0">#</a></h3><p>这是一个最明显的方式。在React类组件中，你可以通过调用这个方法，强制重渲染一个组件：</p><pre><code class="hljs language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forceUpdate</span>();
</code></pre><h3 id="在React hooks中强制更新组件">在React hooks中强制更新组件 <a href="#在React hooks中强制更新组件">#</a></h3><p>在React hooks中，<code>forceUpdate</code>函数是无法使用的。你可以使用如下方式强制更新组件，并且不更改组件的state：</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [state, updateState] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>();
<span class="hljs-keyword">const</span> forceUpdate = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">updateState</span>({}), []);
</code></pre><p><i>我在<a href="https://stackoverflow.com/questions/53215285/how-can-i-force-a-component-to-re-render-with-hooks-in-react/53215514#53215514">StackOverflow</a>中找到这个方式的，你或许永远用不上它。</i></p><h2 id="总结">总结 <a href="#总结">#</a></h2><p>我希望这篇文章可以让你更好的理解React的渲染机制，了解它是如何工作的，并且你可以做哪些工作。关于这篇文章，为了更好的理解React的渲染机制，我做了一些额外的研究。我想要去写更多的关于前端性能的东西，所以如果你想要及时了解到这些，可以关注我，或者订阅邮件。</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/minicode/3d-tetris">上一篇：webgl实现3D俄罗斯方块</a></span><span class="next-article"><a href="/blogs/minicode/webgl-solar-system">下一篇：webgl模拟太阳系动画</a></span></div></div><div class="toc"><div class="toc-header">目录</div><div class="toc-body"><div class="toc-item"><a class="toc-item-link" href="#React组件何时重渲染" style="padding-left:15px">React组件何时重渲染</a></div><div class="toc-item"><a class="toc-item-link" href="#React的渲染" style="padding-left:30px">React的渲染</a></div><div class="toc-item"><a class="toc-item-link" href="#什么是渲染" style="padding-left:45px">什么是渲染</a></div><div class="toc-item"><a class="toc-item-link" href="#什么是虚拟树(VDOM)？" style="padding-left:45px">什么是虚拟树(VDOM)？</a></div><div class="toc-item"><a class="toc-item-link" href="#这对效率意味着什么？" style="padding-left:45px">这对效率意味着什么？</a></div><div class="toc-item"><a class="toc-item-link" href="#如何在实际中看到重渲染过程？" style="padding-left:45px">如何在实际中看到重渲染过程？</a></div><div class="toc-item"><a class="toc-item-link" href="#React何时执行重渲染？" style="padding-left:30px">React何时执行重渲染？</a></div><div class="toc-item"><a class="toc-item-link" href="#当组件props发生改变时，为什么组件不更新？" style="padding-left:45px">当组件props发生改变时，为什么组件不更新？</a></div><div class="toc-item"><a class="toc-item-link" href="#强制React组件重新渲染" style="padding-left:30px">强制React组件重新渲染</a></div><div class="toc-item"><a class="toc-item-link" href="#%E4%BD%BF%E7%94%A8React%E7%9A%84%3Ccode%3EforceUpdate%3C/code%3E%E5%87%BD%E6%95%B0" style="padding-left:45px">使用React的forceUpdate函数</a></div><div class="toc-item"><a class="toc-item-link" href="#在React hooks中强制更新组件" style="padding-left:45px">在React hooks中强制更新组件</a></div><div class="toc-item"><a class="toc-item-link" href="#总结" style="padding-left:30px">总结</a></div></div></div></div></body></html>