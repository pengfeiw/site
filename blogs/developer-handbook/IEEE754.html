<html lang="zh_cn"><head><title>计算机是如何存储浮点数的—IEEE 754 | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="IEEE 754,浮点数存储,计算机小数的存储方式"><meta name="description" content="理解IEEE 754标准，探究计算机是如何存储浮点数的。	"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="body"><div class="nothing"></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2021年11月29日</span><span class="category"><a href="/blogs/developer-handbook">标签：Developer</a></span></div><div class="markdown-body"><h1 id="计算机是如何存储浮点数的—IEEE754">计算机是如何存储浮点数的—IEEE754 <a href="#计算机是如何存储浮点数的—IEEE754">#</a></h1><p>多年以前在大学学习C++时，知道了<a href="https://baike.baidu.com/item/IEEE%20754/3869922">IEEE 754</a>是目前计算机最普遍的浮点数表示方式。但是由于工作上与之打交道甚少，经常忘记这一标准的具体细节，所以我写了这篇文章详细记录下来。</p><h2 id="如何表示数字？">如何表示数字？ <a href="#如何表示数字？">#</a></h2><p>表示数字有很多种方式。例如，我们书写时最常用的方式——固定小数点位置，在几个数字中间放置一个小数点表示小数，如果没有小数点就表示整数。</p><p>还有一种方式，是<strong>科学计数法</strong>，它由基数部分和指数部分组成。例如用科学计数法表示十进制整数<code>50</code>。</p><pre><code class="hljs language-shell">5 x (10 ^ 1)
0.5 x (10 ^ 2)
0.05 x (10 ^ 3)

...
</code></pre><p><code>123.45</code>可以表示成如下几种方式。</p><pre><code class="hljs language-shell">0.12345 x (10 ^ 3)
1.2345 x (10 ^ 2)
12.345 x (10 ^ 1)
123.45 x (10 ^ 0)
1234.5 x (10 ^ -1)

...
</code></pre><p>其中<code>5 x (10 ^ 1)</code>和<code>1.2345 x (10 ^ 2)</code>被称作<strong>标准科学计数法</strong>，其中左侧数字部分的小数点左侧只有一位非0数字。</p><p>如果用标准科学计数法表示，表示二进制数字，则指数的底数为2。</p><p>二进制<code>10100.110</code>表示为<code>1.0100110 × (2 ^ 4)</code>。</p><p><strong>IEEE 754</strong>本质上就是二进制的标准科学计数法。</p><h2 id="IEEE 754">IEEE 754 <a href="#IEEE 754">#</a></h2><p>首先看一下IEEE 754的存储结构。</p><table><thead><tr><th></th><th>符号（Sign）</th><th>指数（Exponent）</th><th>尾数（Fraction）</th></tr></thead><tbody><tr><td>单精度（Single Precision）</td><td>1 [31]</td><td>8 [30-23]</td><td>23 [22-00]</td></tr><tr><td>双精度（Double Precision）</td><td>1 [63]</td><td>11 [62-52]</td><td>52 [51-00]</td></tr></tbody></table><p>C++中单精度浮点数，用4个字节表示，一个字节等于8bit，所以总共有32bit。最左侧一位用来存储符号位，23-30位存储科学计数法的指数部分，0-23位存储科学计数法的非指数部分，这里叫做尾数部分。双精度用8个字节表示，最左侧位为符号位，52-62表示指数部分，0-51表示尾数部分。</p><p>假设符号位为正，指数部分存储的是70，尾数部分是1.1001（二进制），则表示的数值为<code>1.1001 x (2 ^ 70)</code>。</p><p>下面依次解释符号、指数和尾数三个部分。</p><h3 id="符号">符号 <a href="#符号">#</a></h3><p>IEEE 754的符号位用来表示正数和负数，符号位为0表示正数，1表示负数，it's so easy。</p><h3 id="指数">指数 <a href="#指数">#</a></h3><p>单精度结构下，IEEE 754的指数部分有8位，8位可以表示的最大整数为255（2 ^ 8 - 1），因为指数部分既要表示正数，也要表示负数，所以需要有一个偏移值，对于单精度这个偏移值为127，所以指数部分存储的是200，表示的是(200 - 127)，0表示(0 - 127)，即-127。</p><p>双精度结构下，IEEE 754的指数部分有11位，此时计算偏移值为1023，所以0表示-1023。</p><h3 id="尾数">尾数 <a href="#尾数">#</a></h3><p>采用标准的二进制科学计数法，那么尾数部分小数点前肯定是1（二进制只可能是1和0，因为是标准科学计数法，所以是1）。既然确定了小数点前是1，那么不需要再用单独的1个bit表示，所以尾数部分所有bit用来表示小数点右侧的数值。例如存储了<code>100111</code>，那么结果是<code>1.100111</code>，所以32位浮点数的Fraction有32位，但是它表示了24位数值加一个小数点。</p><p>以上，就是通过IEEE 754表示浮点数的过程，如果理解了IEEE 754，很容易能计算出单精度和双精度所能表示的数值范围。</p><h2 id="%3Ccode%3E0.1%20+%200.2%20%EF%BC%81=%200.3%3C/code%3E%20%EF%BC%9F"><code>0.1 + 0.2 ！= 0.3</code> ？ <a href="#%3Ccode%3E0.1%20+%200.2%20%EF%BC%81=%200.3%3C/code%3E%20%EF%BC%9F">#</a></h2><p>在采用 IEEE754 存储浮点数的语言中，存在 <code>0.1 + 0.2 = 0.30000000000000004</code> 的现象。例如 JavaScript、C++等。导致 <code>0.1 + 0.2</code> 不等于 <code>0.3</code> 的原因，正是 IEEE 754 存储浮点数的方式。</p><p><code>0.1</code> 和 <code>0.2</code> 的二进制是一个无限循环的二进制小数，无论是单精度还是双精度，在存储它们时都需要进行截断存取，所以导致 <code>0.1</code> 存储值实际并不是 <code>0.1</code>，存在一个误差，同理存储的 <code>0.2</code> 也存在一个误差，所以计算结果并不是一定准确的。</p><p>所以无论任何时候，在判断两个浮点数数值之和是否等于某个数，一定要考虑一定的误差。</p><p>在 JavaScript 中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON"><code>Number.EPSILON</code></a> 可以用来表示这个误差，我们可以这样判断是否相等。</p><pre><code class="hljs language-javascript">x = <span class="hljs-number">0.2</span>;
y = <span class="hljs-number">0.3</span>;
z = <span class="hljs-number">0.1</span>;
equal = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x - y + z) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>);
</code></pre><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/javascript/javascript-this">上一篇：全面解析JS中的this关键字</a></span><span class="next-article"><a href="/blogs/computer-graphics/bezier-curve">下一篇：贝塞尔曲线</a></span></div></div><div class="toc"><div class="toc-header">目录</div><div class="toc-body"><div class="toc-item"><a class="toc-item-link" href="#计算机是如何存储浮点数的—IEEE754" style="padding-left:15px">计算机是如何存储浮点数的—IEEE754</a></div><div class="toc-item"><a class="toc-item-link" href="#如何表示数字？" style="padding-left:30px">如何表示数字？</a></div><div class="toc-item"><a class="toc-item-link" href="#IEEE 754" style="padding-left:30px">IEEE 754</a></div><div class="toc-item"><a class="toc-item-link" href="#符号" style="padding-left:45px">符号</a></div><div class="toc-item"><a class="toc-item-link" href="#指数" style="padding-left:45px">指数</a></div><div class="toc-item"><a class="toc-item-link" href="#尾数" style="padding-left:45px">尾数</a></div><div class="toc-item"><a class="toc-item-link" href="#%3Ccode%3E0.1%20+%200.2%20%EF%BC%81=%200.3%3C/code%3E%20%EF%BC%9F" style="padding-left:30px">0.1 + 0.2 ！= 0.3 ？</a></div></div></div></div><div class="footer"><span>@2020-2023 Wang Pengfei</span><a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index">皖ICP备2021002453号-1</a></div></body></html>