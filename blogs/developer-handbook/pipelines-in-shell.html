<html lang="zh_cn"><head><title>Pipelines in Shell</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="pipeline,shell,bash,redirect"><meta name="description" content="学习 shell 脚本必须要理解 pipeline 的概念，知道 command 的输入（input）和输出（output）的概念。只有掌握了 pipeline 的机制我们才能更好的写好 shell 脚本."><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.png" alt="rss"></a></div></div></div><a href="/blogs/"><img src="/blogs/assests/images/icon.jpg"></a></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2022年11月26日</span><span class="category"><a href="/blogs/developer-handbook">标签：Developer</a></span></div><div class="markdown-body"><h1 id="Pipelines in Shell">Pipelines in Shell <a href="#Pipelines in Shell">#</a></h1><p>本篇文章内容需要读者知道 shell 的一些语法和作用，知道 shell 的用途，和一些基本的用法。</p><p>学习 shell 脚本必须要理解 pipeline 的概念，知道 command 的输入（input）和输出（output）的概念。只有掌握了 pipeline 的机制我们才能更好的写好 shell 脚本，本章内容详细介绍 pipeline。</p><p>shell 中的 command 可以接受一些输入然后产生一些输出，类似与数学中的函数表达式 <code>y = f(x)</code>，输入参数 <code>x</code>，得到结果 <code>y</code>，command 就可以看作是一个函数方程。</p><h2 id="标准输入、输出和错误">标准输入、输出和错误 <a href="#标准输入、输出和错误">#</a></h2><p><img src="https://pengfeiw.github.io/images/blog/161.jpg" alt="stdin、stdout、stderr"></p><p>每一个程序都会接触到三个比较特殊的文件（linux 中所有东西都是文件）：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code></p><ul><li><code>stdin</code>：standard input 的缩写，意思是标准输入，<strong>大部分</strong>程序从这里读取输入，用数字 <code>0</code> 表示</li><li><code>stdout</code>：standard output 的缩写，意思是标准输出，<strong>大部分</strong>程序将输出信息写入到这个文件里，用数字 <code>1</code> 表示</li><li><code>stderr</code>：standard error 的缩写，意思是标准错误，<strong>大部分</strong>程序出错了需要将错误信息写入这个文件，用数字 <code>2</code> 表示</li></ul><blockquote><p>上面用了 <code>大部分</code> 这个修饰词，意思并不是所有的程序都会按照上面的规范去读取和输出信息，因为任何程序都可以自由选择从哪里读取输入，将输出信息写入哪里。</p></blockquote><p>这三个特殊的文件存储在 <code>dev/</code> （dev 表示 device）文件夹下：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al /dev/std*</span>
lrwxrwxrwx 1 root root 15 Nov 26 20:25 /dev/stderr -&gt; /proc/self/fd/2
lrwxrwxrwx 1 root root 15 Nov 26 20:25 /dev/stdin -&gt; /proc/self/fd/0
lrwxrwxrwx 1 root root 15 Nov 26 20:25 /dev/stdout -&gt; /proc/self/fd/1
</code></pre><p>每次在 shell 中运行一个程序，shell 会将键盘与程序的标准输入关联在一起，并将标准输出和标准错误与终端显示连接在一起：</p><p><img src="https://pengfeiw.github.io/images/blog/162.jpg" alt="stdin、stdout、stderr"></p><p>从上图中我们可以看到数据的流转，键盘 -&gt; stdin 文件 -&gt; program -&gt; stdout/stderr -&gt; 屏幕，这里的数据流转本质上也是 pipeline。</p><h2 id="pipe%EF%BC%88%3Ccode%3E%7C%3C/code%3E%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6">pipe（<code>|</code>）操作符 <a href="#pipe%EF%BC%88%3Ccode%3E%7C%3C/code%3E%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6">#</a></h2><p>可以通过 <code>|</code> 操作符将一个命令的输出重定向到另一个命令的输入，即将一个命令的 <code>stdout</code> 作为 另一个命令的 <code>stdin</code>。动手实践一下：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 file.txt 文件内容</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> file.txt</span>
File
Edit
Selection
view
go
Run
Terminal
help
go
view
<span class="hljs-meta prompt_">
# </span><span class="language-bash">将文件中的内容排序并且去重</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> file.txt | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span></span>
Edit
File
Run
Selection
Terminal
go
help
view
</code></pre><p>重新用途表示 <code>cat test.txt | sort | uniq</code> 的数据流转：</p><p><img src="https://pengfeiw.github.io/images/blog/163.jpg" alt="stdin、stdout、stderr"></p><h2 id="%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91%20%3Ccode%3E<%3C/code%3E">输入重定向 <code>&lt;</code> <a href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91%20%3Ccode%3E<%3C/code%3E">#</a></h2><p><code>&lt;</code> 可以将一个程序的标准输入重定向至某个文件，例如 <code>rev &lt; /dev/stdin</code>，即 rev 命令将从标准输入读取输入，所以 <code>rev &lt; /dev/stdin</code>回车 与 <code>rev</code> 直接回车命令是等价的。</p><h2 id="%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E8%87%B3%E6%96%87%E4%BB%B6%20%3Ccode%3E>%3C/code%3E%20%E5%92%8C%20%3Ccode%3E>>%3C/code%3E">输出重定向至文件 <code>&gt;</code> 和 <code>&gt;&gt;</code> <a href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E8%87%B3%E6%96%87%E4%BB%B6%20%3Ccode%3E>%3C/code%3E%20%E5%92%8C%20%3Ccode%3E>>%3C/code%3E">#</a></h2><ul><li><code>&gt;</code> 将一个命令的输出写入一个文件，并覆盖（override）文件内容</li><li><code>&gt;&gt;</code> 将一个命令的输出内容添加（append）至文件的尾部，不删除文件原有的内容</li></ul><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello Shell"</span> &gt; test.txt</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> test.txt</span>
Hello Shell
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello Pipeline"</span> &gt;&gt; test.txt</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> test.txt</span>
Hello Shell
Hello Pipeline
</code></pre><blockquote><p><code>2&gt;</code> 和 <code>2&gt;&gt;</code> 表示将标准错误重定向至某个文件，<code>2</code> 是标准错误的文件描述符</p></blockquote><h2 id="标准错误">标准错误 <a href="#标准错误">#</a></h2><p>我们试着在同一个路径下创建两个相同的目录，看看会发生什么：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> js</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> js</span>
mkdir: cannot create directory ‘js’: File exists
</code></pre><p>可以看到再次创建同名目录，shell 会报错，这里的错误信息就是标准错误，不是标准输出。我们可以试试使用 pipe 操作符，看能否重定向标准错误。</p><p>测试需要使用 <code>tr</code>（translate characters）命令，可以将字符小写转换为大写，例如：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'Be quiet, this is a library!'</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">'[:lower:]'</span> <span class="hljs-string">'[:upper:]'</span></span>
BE QUIET, THIS IS A LIBRARY!
</code></pre><p>现在我们重定向我们的错误信息：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> js | <span class="hljs-built_in">tr</span> <span class="hljs-string">'[:lower:]'</span> <span class="hljs-string">'[:upper:]'</span></span>
mkdir: cannot create directory ‘js’: File exists
</code></pre><p>可以看到 tr 命令似乎并没有接收到任何标准输入，这是因为 <code>mkdir js</code> 出错了，错误信息输出到了标准错误，而 <code>|</code> 只会重定向标准输出。</p><p>在上面提到过 <code>stdin</code>、<code>stdout</code>、<code>stderr</code> 都有一个文件描述符分别为 <code>0</code>、<code>1</code>、<code>2</code>。</p><p>那如何处理标准错误信息呢？这里有一些常规的做法：</p><p><img src="https://pengfeiw.github.io/images/blog/164.jpg" alt="stdin、stdout、stderr"></p><ul><li><code>2&gt;&amp;1</code>：<code>2&gt;</code> 用于标准错误重定向到某个文件，而 <code>stdin</code>、<code>stdout</code>、<code>stderr</code> 是特殊的文件，所以这里表示标准错误（2）重定向到标准输出（1）</li><li><code>2&gt;./errors.txt</code>：将标准错误信息重定向到某个文件，会覆盖文件原有内容</li><li><code>2&gt;/dev/null</code>: 将标准错误输出到 <code>/dev/null</code></li><li><code>2&gt;&gt;./errors.txt</code>: 将标准错误信息添加到某个文件</li><li><code>&gt;output.txt 2&gt;&amp;1</code>：将标准错误和标准输出都重定向到 <code>output.txt</code> 文件</li></ul><p>我们试着将创建文件夹的报错信息重定向到 <code>error.txt</code> 文件：</p><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> js 2&gt;error.txt</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> error.txt</span>
mkdir: cannot create directory ‘js’: File exists
</code></pre><p><code>2&gt;error.txt</code> 表示重定向错误信息，所以第一次执行 <code>mkdir js</code> 时屏幕上并没有报错信息。</p><h2 id="参考">参考 <a href="#参考">#</a></h2><p>推荐一本非常棒的 shell 学习教程：<a href="https://effective-shell.com/">Effective Shell</a>。</p><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/developer-handbook/shell-job-control">上一篇：Shell 中的工作控制</a></span><span class="next-article"><a href="/blogs/javascript/yarn-workspace">下一篇：Yarn Workspace</a></span></div></div></body></html>