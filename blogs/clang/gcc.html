<html lang="zh_cn"><head><title>gcc 和 g++ | 王鹏飞</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="gcc,g++,c,c++,c/c++,编译,链接,compile,linker,共享库,静态库,动态库,linux"><meta name="description" content="如何用 GCC/G++ 编译 C/C++ 程序，如何编译链接共享库和静态库"><link rel="stylesheet" href="/blogs/assests/code_github.css"><link rel="stylesheet" href="/blogs/assests/github_markdown.css"><link rel="stylesheet" href="/blogs/assests/article.css"><link rel="stylesheet" href="/blogs/assests/navigator.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous"><link rel="icon" href="/blogs/assests/images/icon.jpg"><meta property="author" content="王鹏飞"><script type="text/javascript">window.addEventListener("DOMContentLoaded",function(){document.getElementById("search-input").addEventListener("search",e=>{e.target.value&&window.open(`https://bing.com/search?q=${e.target.value}%20site%3A+pengfeixc.com`,"_blank")})})</script></head><body><div class="header"><div class="navigator"><div class="links"><div class="home"><a href="/blogs">Home</a></div><div class="email"><a href="mailto:pengfeixc@sina.com">Email</a></div><div class="github"><a target="_blank" href="https://github.com/pengfeiw">GitHub</a></div><div clss="minicode"><a target="_blank" href="https://pengfeiw.github.io/minicode">MiniCode</a></div><div class="search"><input id="search-input" type="search" placeholder="search"></div><div class="rss"><a href="/blogs/rss.xml"><img src="/blogs/assests/images/rss.svg" alt="rss"></a></div></div></div></div><div class="body"><div class="nothing"></div><div class="markdown"><div class="markdown-header"><span class="date">日期：2023年2月17日</span><span class="category"><a href="/blogs/clang">标签：C/C++</a></span></div><div class="markdown-body"><h1 id="GCC/G++">GCC/G++ <a href="#GCC/G++">#</a></h1><p>GCC/G++ 是用来编译链接 C/C++ 程序的，长话短说即编译器。这里不介绍它的历史，感兴趣的朋友自行查阅。</p><h2 id="C/C++ 的编译过程">C/C++ 的编译过程 <a href="#C/C++ 的编译过程">#</a></h2><p>介绍 GCC/G++ 之前，先简单说明下 C/C++ 的编译链接生成可执行文件的过程。</p><p><img src="https://pengfeiw.github.io/images/blog/167.jpg" alt="gcc 编译过程"></p><p>1、源文件预处理：通过 c 预处理（cpp.exe）处理源文件中的宏等</p><pre><code class="hljs language-bash">cpp hello.c &gt; hello.i
</code></pre><p>2、编译：gcc/g++ 将经过预处理后的代码编译成汇编程序，<code>-S</code> 选项表示生成汇编程序文件（.s）</p><pre><code class="hljs language-bash">gcc -S hello.i
</code></pre><p>3、使用 as.exe 将汇编程序生成目标文件（.o）</p><pre><code class="hljs language-bash">as -o hello.o hello.s
</code></pre><p>4、最后使用连接器（ld.exe）链接目标文件（.o），生成可执行文件（.out/.exe）</p><pre><code class="hljs language-bash">ld -o hello.out hello.o ...libraries...
</code></pre><h2 id="GCC/G++ 的使用">GCC/G++ 的使用 <a href="#GCC/G++ 的使用">#</a></h2><p>以 GCC 为例，介绍基本使用方法。新建一个 <code>hello.c</code>，写入以下内容：</p><pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, World"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>1、编译并链接 c 文件</p><pre><code class="hljs language-bash">$ gcc hello.c
$ <span class="hljs-built_in">ls</span>
a.out  hello.c
</code></pre><p>默认生成 <code>a.out</code>（linux 上生成的可执行文件为 a.out, windows 为 a.exe）。可以使用 <code>-o</code> 选项指定生成文件的名称。</p><pre><code class="hljs language-bash">$ gcc -o hello hello.c
$ <span class="hljs-built_in">ls</span>
hello hello.c
</code></pre><p>2、编译和链接过程分开</p><p>实际项目中某个文件发生了变化，我们希望单独编译，然后将其编译后的目标文件（.o）与其他目标文件或者库文件链接。可以使用 <code>-c</code> 选项将源文件编译成目标文件（.o）：</p><pre><code class="hljs language-bash">$ gcc -c hello.c
$ <span class="hljs-built_in">ls</span>
hello.c hello.o
</code></pre><p>将目标文件链接成可执行文件，执行的命令与编译并链接相同，当源文件是目标文件时执行的是链接过程，源文件为 C 文件时执行的编译和链接过程。</p><pre><code class="hljs language-bash">$ gcc -o hello hello.o
$ <span class="hljs-built_in">ls</span>
hello hello.c hello.o
</code></pre><p>3、多文件编译链接</p><p>gcc 命令支持多个源文件输入，如果你想把 source1.c 和 source2.c 一起编译：</p><pre><code class="hljs language-bash">$ gcc -o a.out source1.c source2.c
$ <span class="hljs-built_in">ls</span>
a.out source1.c source2.c
</code></pre><p>更多的时候，你可能想分开编译：</p><pre><code class="hljs language-bash">$ gcc -c source1.c
$ gcc -c source2.c
$ gcc -o a.out source1.out source2.out
</code></pre><p>4、编译时打印所有警告信息</p><p>使用 <code>-Wall</code> 选项可以打印所有警告信息，所以使用 gcc 时，一般都会开启该选项：</p><pre><code class="hljs language-bash">$ gcc -Wall -o hello hello.c
</code></pre><p>5、调试</p><p>使用 <code>-g</code> 选项，可以使文件包含调试信息，以提供给 gdb 调试</p><pre><code class="hljs language-bash">$ gcc -Wall -g -o hello hello.c
</code></pre><blockquote><p>gdb 调试教程：<a href="http://pengfeixc.com/blogs/developer-handbook/gdb-debug-1">用 GDB 调试程序</a></p></blockquote><p>6、编译时打印完整的信息</p><p><code>-v</code> 可以打印完整的编译过程信息：</p><pre><code class="hljs language-bash">$ gcc -v -o hello hello.c
</code></pre><h2 id="静态库和共享库">静态库和共享库 <a href="#静态库和共享库">#</a></h2><p>通常我们会把一些公用的方法、变量、类，编译成一个单独的<strong>库</strong>——library，供业务方调用。库本质上是一个包含一个或者多个目标文件（object file）的文件，供<strong>链接阶段</strong>使用。</p><p>库分为两种：<strong>静态库（static library）</strong> 和<strong>共享库（shared library）</strong>，共享库也被叫做<strong>动态库（dynamic）</strong>。它们在行为上有些不同？</p><ul><li>静态库是目标文件（.o）的集合，linux 和 mac 上后缀名为 <code>.a</code>, windows 中后缀名为 <code>.lib</code>。在程序编译过程中的<strong>链接阶段</strong>，与其他目标文件（.o）一起链接形成可执行文件（.out）。所以静态库只在编译阶段起作用，运行时不需要静态库了。</li><li>共享库也是目标文件的集合，linux 中后缀名为 <code>.so</code>（shared object）, mac 中后缀名为 <code>.dylib</code>, windows 中后缀名为 <code>.dll</code>，在程序编译的<strong>链接阶段</strong>和<strong>运行阶段</strong>都起作用。在链接阶段，链接器会验证程序执行所需要的符号（变量、方法等）已经被链接到程序中或者存在于某个共享库中。但是共享库中的目标文件并不会被链接到最终生成的可执行文件中。而在<strong>运行阶段</strong>，程序启动时，系统中有一个程序——**动态加载器（dynamic loader）**会检查哪些动态库被链接到了程序中，并将这些动态库加载到内存中和程序一起执行。所以共享库在程序运行时必须存在。</li></ul><p>静态库相当于在编译时，它里面包含的代码被拷贝到了可执行文件中，而共享库的代码是在运行时被加载到内存中的，所以如果用静态库编译，最终生成的可执行文件会比使用共享库编译得到的可执行文件大。</p><h3 id="静态库的创建和链接">静态库的创建和链接 <a href="#静态库的创建和链接">#</a></h3><p>使用 <strong>ar</strong> 工具创建静态库，ar 具有以下功能。</p><ul><li>创建静态库。</li><li>更改静态库中的目标文件（前面说过静态库就是目标文件的集合）。</li><li>查看静态库中包含的目标文件名称。</li></ul><p>linux 中可以使用 <code>man ar</code> 查看 <code>ar</code> 命令的用法。</p><p><strong>1、创建静态库</strong></p><p>可以用下面的命令创建一个静态库：</p><pre><code class="hljs language-bash">$ ar -rc libutil.a util_file.o util_net.o util_math.o
</code></pre><p>上述命令将 <code>util_file.o</code> <code>util_net.o</code> <code>util_math.o</code> 三个文件打包成静态库 <code>libutil.a</code>，如果 <code>libutil.a</code> 文件已经存在，那么会将 <code>util_file.o</code> <code>util_net.o</code> <code>util_math.o</code> 三个文件添加到静态库中。<code>c</code> 选项表示如果文件不存在则创建库文件，<code>r</code> 选项表示如果某个要打包的目标文件已经存在于库中，则替换掉对应的目标文件。</p><p>也可以用 gcc 的 <code>-static</code> 生成静态库：</p><pre><code class="hljs language-bash">$ gcc *.o -static -o libname.a
</code></pre><p>静态文件名称一般以 <code>lib</code> 前缀开头，<code>.a</code> 后缀结尾，因为链接的时候编译器会根据这个特点查找库文件(下面会说明）。</p><p><strong>2、使用静态库</strong></p><p>当我们创建静态库后，我们想在程序中使用它。可以通过下面的命令将库文件于目标文件一起链接成可执行文件：</p><pre><code class="hljs language-bash">gcc {{目标文件1 目标文件2 ...}} -L&lt;库文件目录&gt; -l&lt;库文件&gt; -o &lt;输出可执行文件名称&gt;
</code></pre><p>例如，下面的例子将目标文件 <code>main.o</code> 与库 <code>libutil.a</code> 链接成可执行文件 prog。</p><pre><code class="hljs language-bash">gcc main.o -L. -lutil -o prog
</code></pre><p>需要注意的是：</p><ul><li><code>-L</code> 选项用于指示库文件目录，<code>.</code> 表示当前目录，所以要链接的库就在当前目录下。</li><li><code>-l</code> 选项用于表示要链接的库文件的名称，要注意我们去掉了库文件名称的前缀 <code>lib</code> 和 后缀 <code>.a</code>，所以库文件名称以 <code>lib</code> 开头，以 <code>.a</code> 结尾。</li><li>注意库文件要放在目标文件的后面，下面详细说明</li></ul><p>在执行 <code>gcc main.o -L. -lutil -o prog</code> 时，假设 <code>main.o</code> 用到了 <code>libutil.a</code> 中的一个函数符号，例如 <code>add</code> 方法，链接器的执行过程如下：</p><ol><li>链接器从左往右扫描目标文件和静态库</li><li>扫描到 <code>main.o</code> 时，发现一个未解析的符号 <code>add</code>，记住这个未解析的符号</li><li>扫描 <code>libutil.a</code> 时找到了前面未解析的符号，因此提取相关代码</li><li>最终没有任何未解析的符号，编译链接完成，生成可执行文件 <code>prog</code></li></ol><p>如果将静态库放到目标文件前面，例如执行 <code>gcc -L. -lutil main.o -o prog</code>，那么链接器的执行过程如下：</p><ol><li>链接器从左往右依次扫描静态库和目标文件</li><li>扫描 <code>libutil.a</code> 时由于前面没有任何未解析的符号，所以不会提取库中的任何代码</li><li>扫描 <code>main.o</code> 时，发现未解析的符号 exp</li><li>扫描结束，存在未解析的符号，因此编译链接报错</li></ol><h3 id="共享库的创建和链接">共享库的创建和链接 <a href="#共享库的创建和链接">#</a></h3><p>创建共享库（动态库）的过程和静态库其实没什么区别，都是将一组目标文件编译插入到一个库文件中。但是再链接动态库时，并不是将需要的二进制代码都“拷贝”到可执行文件中，二十仅“拷贝”一些重定位和符号信息，有了这些信息，在程序运行时会完成真正的链接过程。</p><p>1、创建共享库 gcc 的 <code>-shared</code> 参数可以创建共享库：</p><pre><code class="hljs language-bash"><span class="hljs-comment"># 生成目标文件</span>
$ gcc -fPIC -c *.c
<span class="hljs-comment"># 将目标文件编译成共享库</span>
$ gcc –shared –o *.so *.o
</code></pre><p>2、链接共享库</p><p>链接共享库与链接动态库命令一致，由于 gcc 默认采用动态链接，如果存在同名的动态库和静态库，gcc 会链接动态库，可以使用 <code>-static</code> 指定链接静态库。</p><pre><code class="hljs language-bash">$ gcc main.o -L. -lutil -o prog
</code></pre><p>上面的命令会链接 <code>libutil.so</code> 文件。</p><p>通常程序运行时，系统动态加载（dynamic loader）起会在系统指定的一些目录下寻找共享库（例如 /lib, /usr/x11/lib 等等）。当我们创建了一个共享库，我们可以使用 <code>LD_LIBRARY_PATH</code> 环境变量告诉<strong>动态加载器</strong>在指定目录下寻找。</p><pre><code class="hljs language-bash">LD_LIBRARY_PATH=/full/path/to/library/directory:<span class="hljs-variable">${LD_LIBRARY_PATH}</span>
<span class="hljs-built_in">export</span> LD_LIBRARY_PATH
</code></pre><p>可以使用 ldd 命令查看可执行文件所依赖的共享库：</p><pre><code class="hljs language-bash">$ ldd prog
</code></pre><h2 id="参考">参考 <a href="#参考">#</a></h2><ul><li><a href="https://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html">Building And Using Static And Shared "C" Libraries</a></li></ul><p>（完）</p></div><div class="markdown-footer"><span class="pre-article"><a href="/blogs/developer-handbook/full-adder">上一篇：计算机如何用二进制计数</a></span><span class="next-article"><a href="/blogs/clang/make-tutorial">下一篇：Make 命令教程</a></span></div></div><div class="toc"><div class="toc-header">目录</div><div class="toc-body"><div class="toc-item"><a class="toc-item-link" href="#GCC/G++" style="padding-left:15px">GCC/G++</a></div><div class="toc-item"><a class="toc-item-link" href="#C/C++ 的编译过程" style="padding-left:30px">C/C++ 的编译过程</a></div><div class="toc-item"><a class="toc-item-link" href="#GCC/G++ 的使用" style="padding-left:30px">GCC/G++ 的使用</a></div><div class="toc-item"><a class="toc-item-link" href="#静态库和共享库" style="padding-left:30px">静态库和共享库</a></div><div class="toc-item"><a class="toc-item-link" href="#静态库的创建和链接" style="padding-left:45px">静态库的创建和链接</a></div><div class="toc-item"><a class="toc-item-link" href="#共享库的创建和链接" style="padding-left:45px">共享库的创建和链接</a></div><div class="toc-item"><a class="toc-item-link" href="#参考" style="padding-left:30px">参考</a></div></div></div></div></body></html>